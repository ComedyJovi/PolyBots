#include <stdio.h>
#include <inttypes.h>
#include "drivers/mss_i2c/mss_i2c.h"
#include "mss_timer.h"

#define TIMER_FREQ 100000000

#define PIXY_START_WORD             	0xaa55
#define PIXY_START_WORD_CC          	0xaa56
#define PIXY_START_WORDX            	0x55aa
#define PIXY_I2C_DEFAULT_ADDR           0x54

#define PIXY_OBJECT_COUNT 3
#define PIXY_UNION_U8_SIZE 14
#define PIXY_UNION_U16_SIZE PIXY_UNION_U8_SIZE/2
#define PIXY_RECIEVE_BUFF_SIZE (PIXY_UNION_U8_SIZE * PIXY_OBJECT_COUNT)+16

#define PIXY_READ_PERIOD TIMER_FREQ / 5 //10000000

union pixy_data_union{
	uint8_t u8[PIXY_UNION_U8_SIZE];
	uint16_t u16[PIXY_UNION_U16_SIZE];
	struct{
		uint16_t sync;
		uint16_t crc;
		uint16_t id;
		uint16_t x;
		uint16_t y;
		uint16_t width;
		uint16_t height;
	}o;
};

// used to invert endienness
union data_buffer_u{
	uint8_t u8[PIXY_RECIEVE_BUFF_SIZE];
	uint16_t u16[PIXY_RECIEVE_BUFF_SIZE/2];
};



union data_buffer_u receive_buf;
int print_flag;

/* *
 * This function takes in the data from i2c
 * it switches the endienness of bytes and
 * accumulates then in an easy to read union
 * */
//int process_pixy_obj(uint8_t *buff, union pixy_data_union * p_buff){
//	int i;
//
//	//flip byte endienness
//	for (i = 0; i < PIXY_BUFFER_U8_SIZE; i+=1){
//		p_buff->u8[i] = buff[i];
//	}
//
//	if(p_buff->o.sync != PIXY_START_WORD || p_buff->o.sync != PIXY_START_WORD_CC){
//		printf("error with block sync bytes\n\r");
//		return 0;
//	}
//	return 1;
//}

/*
 * for testing
 * print pixy data
 * */
void pixy_print(union pixy_data_union *p){
	printf("\n\r\n\r");
	printf("id: %" PRIu16"\n\r", p[0].o.id);
//	printf("x: %" PRIu16"\n\r", p[0].o.x);
//	printf("y: %" PRIu16"\n\r", p[0].o.y);
//	printf("width: %" PRIu16"\n\r", p[0].o.width);
//	printf("height: %" PRIu16"\n\r", p[0].o.height);
}

void pixy_read_multiple(union data_buffer_u *r_buff, union pixy_data_union *pixy_union_arr){
	int obj_index, buff_index;

	//check if the start bits match expected
	if(r_buff->u16[0] != PIXY_START_WORD || r_buff->u16[1] != PIXY_START_WORD){
		//TODO: find a way to prompt the camera to reset its buffer
//		MSS_I2C_read(&g_mss_i2c1, PIXY_I2C_DEFAULT_ADDR, dummy_buf.u8, PIXY_RECIEVE_BUFF_SIZE, MSS_I2C_RELEASE_BUS);
//		MSS_I2C_wait_complete(&g_mss_i2c1,MSS_I2C_NO_TIMEOUT);
		printf("Bad start bits in buffer...\n\r");
		return;
	}

	for (obj_index = 0; obj_index < PIXY_OBJECT_COUNT; obj_index++){
		for(buff_index = 0 ; buff_index < PIXY_UNION_U16_SIZE ; buff_index++){
			pixy_union_arr[obj_index].u16[buff_index] = r_buff->u16[(obj_index*PIXY_UNION_U16_SIZE) + buff_index + 1];
		}
	}

	if(print_flag){
		for (obj_index = 0, buff_index = 1; obj_index < PIXY_OBJECT_COUNT; obj_index++){
			pixy_print(&pixy_union_arr[obj_index]);
		}
		print_flag = 0;
	}

}

/* *
 * setup a continuous hardware timer with interrupt that reads
 * */
void start_hardware_cont_timer( void ){
	MSS_TIM1_init(MSS_TIMER_PERIODIC_MODE);
	MSS_TIM1_load_background(PIXY_READ_PERIOD);
	MSS_TIM1_start();
	MSS_TIM1_enable_irq();
}

void shift_recieve_union(){
	int i ;
	for(i = 0; i < sizeof(receive_buf)-1; i ++){
		receive_buf[i]
	}
}

/* *
 * hardware timer down counting at 100MHz
 * hardware timer down counting
 * */
void Timer1_IRQHandler( void ){
	MSS_I2C_read(&g_mss_i2c1, PIXY_I2C_DEFAULT_ADDR, receive_buf.u8, PIXY_RECIEVE_BUFF_SIZE, MSS_I2C_RELEASE_BUS);
	MSS_TIM1_clear_irq();
	print_flag = 1;
}


int main(void)
{
	union pixy_data_union pixy_data[PIXY_OBJECT_COUNT];

	MSS_I2C_init(&g_mss_i2c1 , PIXY_I2C_DEFAULT_ADDR, MSS_I2C_PCLK_DIV_256 );
	start_hardware_cont_timer();

	while(1){
		switch(MSS_I2C_get_status(&g_mss_i2c1)){
		case MSS_I2C_SUCCESS:
			if (print_flag){
				if(receive_buf.u8[0] == 0){
					receive_buf.u8 = receive_buf.u8+1;
				}
				printf("%x%x",receive_buf.u16[0], receive_buf.u16[1]);
				printf("%x\n\r",receive_buf.u16[2]);
				//pixy_read_multiple(&receive_buf, pixy_data);
			}
			break;
		case MSS_I2C_IN_PROGRESS:
			break;
		case MSS_I2C_FAILED:
		case MSS_I2C_TIMED_OUT:
		default:
			printf("i2c transmission issues %x\n\r", MSS_I2C_get_status(&g_mss_i2c1));
		}
	}
}

